# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.28.0
#   sqlc-gen-better-python v0.4.0
"""Module containing queries from file queries.sql."""
from __future__ import annotations

__all__: collections.abc.Sequence[str] = (
    "QueryResults",
    "create_rows_table",
    "delete_last_id_one_sqlite_type",
    "delete_one_sqlite_type",
    "delete_one_test_inner_sqlite_type",
    "delete_result_one_sqlite_type",
    "delete_rows_one_sqlite_type",
    "get_many_blob",
    "get_many_bool",
    "get_many_boolean",
    "get_many_date",
    "get_many_datetime",
    "get_many_decimal",
    "get_many_inner_sqlite_type",
    "get_many_nullable_inner_sqlite_type",
    "get_many_sqlite_type",
    "get_many_timestamp",
    "get_one_blob",
    "get_one_bool",
    "get_one_boolean",
    "get_one_date",
    "get_one_datetime",
    "get_one_decimal",
    "get_one_inner_sqlite_type",
    "get_one_sqlite_type",
    "get_one_timestamp",
    "insert_last_id_one_sqlite_type",
    "insert_one_inner_sqlite_type",
    "insert_one_sqlite_type",
    "insert_result_one_sqlite_type",
    "insert_rows_one_sqlite_type",
    "update_last_id_one_sqlite_type",
    "update_result_one_sqlite_type",
    "update_rows_one_sqlite_type",
)

import aiosqlite
import datetime
import decimal
import typing

if typing.TYPE_CHECKING:
    import collections.abc
    import sqlite3

    QueryResultsArgsType: typing.TypeAlias = int | float | str | memoryview | None | decimal.Decimal | datetime.date | datetime.time | datetime.datetime | datetime.timedelta

from test.driver_aiosqlite.dataclass.functions import models


def _adapt_date(val: datetime.date) -> str:
    return val.isoformat()

def _convert_date(val: bytes) -> datetime.date:
    return datetime.date.fromisoformat(val.decode())

def _adapt_decimal(val: decimal.Decimal) -> str:
    return str(val)

def _convert_decimal(val: bytes) -> decimal.Decimal:
    return decimal.Decimal(val.decode())

def _adapt_datetime(val: datetime.datetime) -> str:
    return val.isoformat()

def _convert_datetime(val: bytes) -> datetime.datetime:
    return datetime.datetime.fromisoformat(val.decode())

def _adapt_bool(val: bool) -> int:
    return int(val)

def _convert_bool(val: bytes) -> bool:
    return bool(int(val))

def _adapt_memoryview(val: memoryview) -> bytes:
    return val.tobytes()

def _convert_memoryview(val: bytes) -> memoryview:
    return memoryview(val)

aiosqlite.register_adapter(datetime.date, _adapt_date)
aiosqlite.register_adapter(decimal.Decimal, _adapt_decimal)
aiosqlite.register_adapter(datetime.datetime, _adapt_datetime)
aiosqlite.register_adapter(bool, _adapt_bool)
aiosqlite.register_adapter(memoryview, _adapt_memoryview)

aiosqlite.register_converter("date", _convert_date)
aiosqlite.register_converter("decimal", _convert_decimal)
aiosqlite.register_converter("datetime", _convert_datetime)
aiosqlite.register_converter("timestamp", _convert_datetime)
aiosqlite.register_converter("bool", _convert_bool)
aiosqlite.register_converter("boolean", _convert_bool)
aiosqlite.register_converter("blob", _convert_memoryview)

CREATE_ROWS_TABLE: typing.Final[str] = """-- name: CreateRowsTable :execrows
CREATE TABLE test_create_rows_table
(
    id   int PRIMARY KEY NOT NULL,
    test int             NOT NULL
)
"""

DELETE_LAST_ID_ONE_SQLITE_TYPE: typing.Final[str] = """-- name: DeleteLastIdOneSqliteType :execlastid
DELETE
FROM test_sqlite_types
WHERE test_sqlite_types.id = ?
"""

DELETE_ONE_SQLITE_TYPE: typing.Final[str] = """-- name: DeleteOneSqliteType :exec
DELETE
FROM test_sqlite_types
WHERE test_sqlite_types.id = ?
"""

DELETE_ONE_TEST_INNER_SQLITE_TYPE: typing.Final[str] = """-- name: DeleteOneTestInnerSqliteType :exec
DELETE FROM test_inner_sqlite_types
WHERE test_inner_sqlite_types.table_id = ?
"""

DELETE_RESULT_ONE_SQLITE_TYPE: typing.Final[str] = """-- name: DeleteResultOneSqliteType :execresult
DELETE
FROM test_sqlite_types
WHERE test_sqlite_types.id = ?
"""

DELETE_ROWS_ONE_SQLITE_TYPE: typing.Final[str] = """-- name: DeleteRowsOneSqliteType :execrows
DELETE
FROM test_sqlite_types
WHERE test_sqlite_types.id = ?
"""

GET_MANY_BLOB: typing.Final[str] = """-- name: GetManyBlob :many
SELECT blob_test FROM test_sqlite_types WHERE id = ? AND blob_test = ?
"""

GET_MANY_BOOL: typing.Final[str] = """-- name: GetManyBool :many
SELECT bool_test FROM test_sqlite_types WHERE id = ? AND bool_test = ?
"""

GET_MANY_BOOLEAN: typing.Final[str] = """-- name: GetManyBoolean :many
SELECT boolean_test FROM test_sqlite_types WHERE id = ? AND boolean_test = ?
"""

GET_MANY_DATE: typing.Final[str] = """-- name: GetManyDate :many
SELECT date_test FROM test_sqlite_types WHERE id = ? AND date_test = ?
"""

GET_MANY_DATETIME: typing.Final[str] = """-- name: GetManyDatetime :many
SELECT datetime_test FROM test_sqlite_types WHERE id = ? AND datetime_test = ?
"""

GET_MANY_DECIMAL: typing.Final[str] = """-- name: GetManyDecimal :many
SELECT decimal_test FROM test_sqlite_types WHERE id = ? AND decimal_test = ?
"""

GET_MANY_INNER_SQLITE_TYPE: typing.Final[str] = """-- name: GetManyInnerSqliteType :many
SELECT table_id, int_test, bigint_test, smallint_test, tinyint_test, int2_test, int8_test, bigserial_test, blob_test, real_test, double_test, double_precision_test, float_test, numeric_test, decimal_test, boolean_test, bool_test, date_test, datetime_test, timestamp_test, character_test, varchar_test, varyingcharacter_test, nchar_test, nativecharacter_test, nvarchar_test, text_test, clob_test, json_test FROM test_inner_sqlite_types WHERE table_id = ?
"""

GET_MANY_NULLABLE_INNER_SQLITE_TYPE: typing.Final[str] = """-- name: GetManyNullableInnerSqliteType :many
SELECT table_id, int_test, bigint_test, smallint_test, tinyint_test, int2_test, int8_test, bigserial_test, blob_test, real_test, double_test, double_precision_test, float_test, numeric_test, decimal_test, boolean_test, bool_test, date_test, datetime_test, timestamp_test, character_test, varchar_test, varyingcharacter_test, nchar_test, nativecharacter_test, nvarchar_test, text_test, clob_test, json_test FROM test_inner_sqlite_types WHERE table_id = ? AND int_test = ?
"""

GET_MANY_SQLITE_TYPE: typing.Final[str] = """-- name: GetManySqliteType :many
SELECT id, int_test, bigint_test, smallint_test, tinyint_test, int2_test, int8_test, bigserial_test, blob_test, real_test, double_test, double_precision_test, float_test, numeric_test, decimal_test, boolean_test, bool_test, date_test, datetime_test, timestamp_test, character_test, varchar_test, varyingcharacter_test, nchar_test, nativecharacter_test, nvarchar_test, text_test, clob_test, json_test FROM test_sqlite_types WHERE id = ?
"""

GET_MANY_TIMESTAMP: typing.Final[str] = """-- name: GetManyTimestamp :many
SELECT timestamp_test FROM test_sqlite_types WHERE id = ? AND timestamp_test = ?
"""

GET_ONE_BLOB: typing.Final[str] = """-- name: GetOneBlob :one
SELECT blob_test FROM test_sqlite_types WHERE id = ? AND blob_test = ?
"""

GET_ONE_BOOL: typing.Final[str] = """-- name: GetOneBool :one
SELECT bool_test FROM test_sqlite_types WHERE id = ? AND bool_test = ?
"""

GET_ONE_BOOLEAN: typing.Final[str] = """-- name: GetOneBoolean :one
SELECT boolean_test FROM test_sqlite_types WHERE id = ? AND boolean_test = ?
"""

GET_ONE_DATE: typing.Final[str] = """-- name: GetOneDate :one
SELECT date_test FROM test_sqlite_types WHERE id = ? AND date_test = ?
"""

GET_ONE_DATETIME: typing.Final[str] = """-- name: GetOneDatetime :one
SELECT datetime_test FROM test_sqlite_types WHERE id = ? AND datetime_test = ?
"""

GET_ONE_DECIMAL: typing.Final[str] = """-- name: GetOneDecimal :one
SELECT decimal_test FROM test_sqlite_types WHERE id = ? AND decimal_test = ?
"""

GET_ONE_INNER_SQLITE_TYPE: typing.Final[str] = """-- name: GetOneInnerSqliteType :one
SELECT table_id, int_test, bigint_test, smallint_test, tinyint_test, int2_test, int8_test, bigserial_test, blob_test, real_test, double_test, double_precision_test, float_test, numeric_test, decimal_test, boolean_test, bool_test, date_test, datetime_test, timestamp_test, character_test, varchar_test, varyingcharacter_test, nchar_test, nativecharacter_test, nvarchar_test, text_test, clob_test, json_test FROM test_inner_sqlite_types WHERE table_id = ?
"""

GET_ONE_SQLITE_TYPE: typing.Final[str] = """-- name: GetOneSqliteType :one
SELECT id, int_test, bigint_test, smallint_test, tinyint_test, int2_test, int8_test, bigserial_test, blob_test, real_test, double_test, double_precision_test, float_test, numeric_test, decimal_test, boolean_test, bool_test, date_test, datetime_test, timestamp_test, character_test, varchar_test, varyingcharacter_test, nchar_test, nativecharacter_test, nvarchar_test, text_test, clob_test, json_test FROM test_sqlite_types WHERE id = ?
"""

GET_ONE_TIMESTAMP: typing.Final[str] = """-- name: GetOneTimestamp :one
SELECT timestamp_test FROM test_sqlite_types WHERE id = ? AND timestamp_test = ?
"""

INSERT_LAST_ID_ONE_SQLITE_TYPE: typing.Final[str] = """-- name: InsertLastIdOneSqliteType :execlastid
INSERT INTO test_sqlite_types (
    id, int_test, bigint_test, smallint_test, tinyint_test, int2_test, int8_test, bigserial_test,
    blob_test, real_test, double_test, double_precision_test, float_test, numeric_test, decimal_test,
    boolean_test, bool_test, date_test, datetime_test, timestamp_test,
    character_test, varchar_test, varyingcharacter_test, nchar_test, nativecharacter_test,
    nvarchar_test, text_test, clob_test, json_test
) VALUES (
             ?, ?, ?, ?, ?, ?, ?, ?,
             ?, ?, ?, ?, ?, ?, ?,
             ?, ?, ?, ?, ?,
             ?, ?, ?, ?, ?, ?, ?, ?, ?
         )
"""

INSERT_ONE_INNER_SQLITE_TYPE: typing.Final[str] = """-- name: InsertOneInnerSqliteType :exec
INSERT INTO test_inner_sqlite_types (
    table_id, int_test, bigint_test, smallint_test, tinyint_test, int2_test, int8_test, bigserial_test,
    blob_test, real_test, double_test, double_precision_test, float_test, numeric_test, decimal_test,
    boolean_test, bool_test, date_test, datetime_test, timestamp_test,
    character_test, varchar_test, varyingcharacter_test, nchar_test, nativecharacter_test,
    nvarchar_test, text_test, clob_test, json_test
) VALUES (
             ?, ?, ?, ?, ?, ?, ?, ?,
             ?, ?, ?, ?, ?, ?, ?,
             ?, ?, ?, ?, ?,
             ?, ?, ?, ?, ?, ?, ?, ?, ?
         )
"""

INSERT_ONE_SQLITE_TYPE: typing.Final[str] = """-- name: InsertOneSqliteType :exec
INSERT INTO test_sqlite_types (
    id, int_test, bigint_test, smallint_test, tinyint_test, int2_test, int8_test, bigserial_test,
    blob_test, real_test, double_test, double_precision_test, float_test, numeric_test, decimal_test,
    boolean_test, bool_test, date_test, datetime_test, timestamp_test,
    character_test, varchar_test, varyingcharacter_test, nchar_test, nativecharacter_test,
    nvarchar_test, text_test, clob_test, json_test
) VALUES (
             ?, ?, ?, ?, ?, ?, ?, ?,
             ?, ?, ?, ?, ?, ?, ?,
             ?, ?, ?, ?, ?,
             ?, ?, ?, ?, ?, ?, ?, ?, ?
         )
"""

INSERT_RESULT_ONE_SQLITE_TYPE: typing.Final[str] = """-- name: InsertResultOneSqliteType :execresult
INSERT INTO test_sqlite_types (
    id, int_test, bigint_test, smallint_test, tinyint_test, int2_test, int8_test, bigserial_test,
    blob_test, real_test, double_test, double_precision_test, float_test, numeric_test, decimal_test,
    boolean_test, bool_test, date_test, datetime_test, timestamp_test,
    character_test, varchar_test, varyingcharacter_test, nchar_test, nativecharacter_test,
    nvarchar_test, text_test, clob_test, json_test
) VALUES (
             ?, ?, ?, ?, ?, ?, ?, ?,
             ?, ?, ?, ?, ?, ?, ?,
             ?, ?, ?, ?, ?,
             ?, ?, ?, ?, ?, ?, ?, ?, ?
         )
"""

INSERT_ROWS_ONE_SQLITE_TYPE: typing.Final[str] = """-- name: InsertRowsOneSqliteType :execrows
INSERT INTO test_sqlite_types (
    id, int_test, bigint_test, smallint_test, tinyint_test, int2_test, int8_test, bigserial_test,
    blob_test, real_test, double_test, double_precision_test, float_test, numeric_test, decimal_test,
    boolean_test, bool_test, date_test, datetime_test, timestamp_test,
    character_test, varchar_test, varyingcharacter_test, nchar_test, nativecharacter_test,
    nvarchar_test, text_test, clob_test, json_test
) VALUES (
             ?, ?, ?, ?, ?, ?, ?, ?,
             ?, ?, ?, ?, ?, ?, ?,
             ?, ?, ?, ?, ?,
             ?, ?, ?, ?, ?, ?, ?, ?, ?
         )
"""

UPDATE_LAST_ID_ONE_SQLITE_TYPE: typing.Final[str] = """-- name: UpdateLastIdOneSqliteType :execlastid
UPDATE test_sqlite_types
SET int_test = 187
WHERE test_sqlite_types.id = ?
"""

UPDATE_RESULT_ONE_SQLITE_TYPE: typing.Final[str] = """-- name: UpdateResultOneSqliteType :execresult
UPDATE test_sqlite_types
SET int_test = 187
WHERE test_sqlite_types.id = ?
"""

UPDATE_ROWS_ONE_SQLITE_TYPE: typing.Final[str] = """-- name: UpdateRowsOneSqliteType :execrows
UPDATE test_sqlite_types
SET int_test = 187
WHERE test_sqlite_types.id = ?
"""


T = typing.TypeVar("T")

class QueryResults(typing.Generic[T]):
    """Helper class that allows both iteration and normal fetching of data from the db."""

    __slots__ = ("_args", "_conn", "_cursor", "_decode_hook", "_iterator", "_sql")

    def __init__(
        self,
        conn: aiosqlite.Connection,
        sql: str,
        decode_hook: collections.abc.Callable[[sqlite3.Row], T],
        *args: QueryResultsArgsType,
    ) -> None:
        """Initialize the QueryResults instance.

        Args:
            conn:
                The connection object of type `aiosqlite.Connection` used to execute queries.
            sql:
                The SQL statement that will be executed when fetching/iterating.
            decode_hook:
                A callback that turns an `sqlite3.Row` object into `T` that will be returned.
            *args:
                Arguments that should be sent when executing the sql query.
        """
        self._conn = conn
        self._sql = sql
        self._decode_hook = decode_hook
        self._args = args
        self._cursor: aiosqlite.Cursor | None = None
        self._iterator: collections.abc.AsyncIterator[sqlite3.Row] | None = None

    def __aiter__(self) -> QueryResults[T]:
        """Initialize iteration support for `async for`.

        Returns:
            Self as an asynchronous iterator.
        """
        return self

    def __await__(
        self,
    ) -> collections.abc.Generator[None, None, collections.abc.Sequence[T]]:
        """Allow `await` on the object to return all rows as a fully decoded sequence.

        Returns:
            A sequence of decoded objects of type `T`.
        """
        async def _wrapper() -> collections.abc.Sequence[T]:
            result = await (await self._conn.execute(self._sql, self._args)).fetchall()
            return [self._decode_hook(row) for row in result]
        return _wrapper().__await__()

    async def __anext__(self) -> T:
        """Yield the next item in the query result using an aiosqlite cursor.

        Returns:
            The next decoded result of type `T`.

        Raises:
            StopAsyncIteration: When no more records are available.
        """
        if self._cursor is None or self._iterator is None:
            self._cursor: aiosqlite.Cursor | None = await self._conn.execute(self._sql, self._args)
            self._iterator = self._cursor.__aiter__()
        try:
            record = await self._iterator.__anext__()
        except StopAsyncIteration:
            self._cursor = None
            self._iterator = None
            raise
        return self._decode_hook(record)

async def create_rows_table(conn: aiosqlite.Connection) -> int:
    """Execute SQL query with `name: CreateRowsTable :execrows` and return the number of affected rows.

    ```sql
    CREATE TABLE test_create_rows_table
    (
        id   int PRIMARY KEY NOT NULL,
        test int             NOT NULL
    )
    ```

    Args:
        conn:
            Connection object of type `aiosqlite.Connection` used to execute the query.

    Returns:
        The number (`int`) of affected rows. This will be -1 for queries like `CREATE TABLE`.
    """
    return (await conn.execute(CREATE_ROWS_TABLE)).rowcount


async def delete_last_id_one_sqlite_type(conn: aiosqlite.Connection, *, id_: int) -> int | None:
    """Execute SQL query with `name: DeleteLastIdOneSqliteType :execlastid` and return the id of the last affected row.

    ```sql
    DELETE
    FROM test_sqlite_types
    WHERE test_sqlite_types.id = ?
    ```

    Args:
        conn:
            Connection object of type `aiosqlite.Connection` used to execute the query.
        id_: int.

    Returns:
        The id (`int | None`) of the last affected row. Will be `None` if no rows are affected.
    """
    return (await conn.execute(DELETE_LAST_ID_ONE_SQLITE_TYPE,(id_, ))).lastrowid


async def delete_one_sqlite_type(conn: aiosqlite.Connection, *, id_: int) -> None:
    """Execute SQL query with `name: DeleteOneSqliteType :exec`.

    ```sql
    DELETE
    FROM test_sqlite_types
    WHERE test_sqlite_types.id = ?
    ```

    Args:
        conn:
            Connection object of type `aiosqlite.Connection` used to execute the query.
        id_: int.
    """
    await conn.execute(DELETE_ONE_SQLITE_TYPE,(id_, ))


async def delete_one_test_inner_sqlite_type(conn: aiosqlite.Connection, *, table_id: int) -> None:
    """Execute SQL query with `name: DeleteOneTestInnerSqliteType :exec`.

    ```sql
    DELETE FROM test_inner_sqlite_types
    WHERE test_inner_sqlite_types.table_id = ?
    ```

    Args:
        conn:
            Connection object of type `aiosqlite.Connection` used to execute the query.
        table_id: int.
    """
    await conn.execute(DELETE_ONE_TEST_INNER_SQLITE_TYPE,(table_id, ))


async def delete_result_one_sqlite_type(conn: aiosqlite.Connection, *, id_: int) -> aiosqlite.Cursor:
    """Execute and return the result of SQL query with `name: DeleteResultOneSqliteType :execresult`.

    ```sql
    DELETE
    FROM test_sqlite_types
    WHERE test_sqlite_types.id = ?
    ```

    Args:
        conn:
            Connection object of type `aiosqlite.Connection` used to execute the query.
        id_: int.

    Returns:
        The result of type `aiosqlite.Cursor` returned when executing the query.
    """
    return await conn.execute(DELETE_RESULT_ONE_SQLITE_TYPE,(id_, ))


async def delete_rows_one_sqlite_type(conn: aiosqlite.Connection, *, id_: int) -> int:
    """Execute SQL query with `name: DeleteRowsOneSqliteType :execrows` and return the number of affected rows.

    ```sql
    DELETE
    FROM test_sqlite_types
    WHERE test_sqlite_types.id = ?
    ```

    Args:
        conn:
            Connection object of type `aiosqlite.Connection` used to execute the query.
        id_: int.

    Returns:
        The number (`int`) of affected rows. This will be -1 for queries like `CREATE TABLE`.
    """
    return (await conn.execute(DELETE_ROWS_ONE_SQLITE_TYPE,(id_, ))).rowcount


def get_many_blob(conn: aiosqlite.Connection, *, id_: int, blob_test: memoryview) -> QueryResults[memoryview]:
    """Fetch many from the db using the SQL query with `name: GetManyBlob :many`.

    ```sql
    SELECT blob_test FROM test_sqlite_types WHERE id = ? AND blob_test = ?
    ```

    Args:
        conn:
            Connection object of type `aiosqlite.Connection` used to execute the query.
        id_: int.
        blob_test: memoryview.

    Returns:
        Helper class of type `QueryResults[memoryview]` that allows both iteration and normal fetching of data from the db.
    """
    def _decode_hook(row: sqlite3.Row) -> memoryview:
        return row[0]
    return QueryResults[memoryview](conn, GET_MANY_BLOB, _decode_hook, id_, blob_test)


def get_many_bool(conn: aiosqlite.Connection, *, id_: int, bool_test: bool) -> QueryResults[bool]:
    """Fetch many from the db using the SQL query with `name: GetManyBool :many`.

    ```sql
    SELECT bool_test FROM test_sqlite_types WHERE id = ? AND bool_test = ?
    ```

    Args:
        conn:
            Connection object of type `aiosqlite.Connection` used to execute the query.
        id_: int.
        bool_test: bool.

    Returns:
        Helper class of type `QueryResults[bool]` that allows both iteration and normal fetching of data from the db.
    """
    def _decode_hook(row: sqlite3.Row) -> bool:
        return row[0]
    return QueryResults[bool](conn, GET_MANY_BOOL, _decode_hook, id_, bool_test)


def get_many_boolean(conn: aiosqlite.Connection, *, id_: int, boolean_test: bool) -> QueryResults[bool]:
    """Fetch many from the db using the SQL query with `name: GetManyBoolean :many`.

    ```sql
    SELECT boolean_test FROM test_sqlite_types WHERE id = ? AND boolean_test = ?
    ```

    Args:
        conn:
            Connection object of type `aiosqlite.Connection` used to execute the query.
        id_: int.
        boolean_test: bool.

    Returns:
        Helper class of type `QueryResults[bool]` that allows both iteration and normal fetching of data from the db.
    """
    def _decode_hook(row: sqlite3.Row) -> bool:
        return row[0]
    return QueryResults[bool](conn, GET_MANY_BOOLEAN, _decode_hook, id_, boolean_test)


def get_many_date(conn: aiosqlite.Connection, *, id_: int, date_test: datetime.date) -> QueryResults[datetime.date]:
    """Fetch many from the db using the SQL query with `name: GetManyDate :many`.

    ```sql
    SELECT date_test FROM test_sqlite_types WHERE id = ? AND date_test = ?
    ```

    Args:
        conn:
            Connection object of type `aiosqlite.Connection` used to execute the query.
        id_: int.
        date_test: datetime.date.

    Returns:
        Helper class of type `QueryResults[datetime.date]` that allows both iteration and normal fetching of data from the db.
    """
    def _decode_hook(row: sqlite3.Row) -> datetime.date:
        return row[0]
    return QueryResults[datetime.date](conn, GET_MANY_DATE, _decode_hook, id_, date_test)


def get_many_datetime(conn: aiosqlite.Connection, *, id_: int, datetime_test: datetime.datetime) -> QueryResults[datetime.datetime]:
    """Fetch many from the db using the SQL query with `name: GetManyDatetime :many`.

    ```sql
    SELECT datetime_test FROM test_sqlite_types WHERE id = ? AND datetime_test = ?
    ```

    Args:
        conn:
            Connection object of type `aiosqlite.Connection` used to execute the query.
        id_: int.
        datetime_test: datetime.datetime.

    Returns:
        Helper class of type `QueryResults[datetime.datetime]` that allows both iteration and normal fetching of data from the db.
    """
    def _decode_hook(row: sqlite3.Row) -> datetime.datetime:
        return row[0]
    return QueryResults[datetime.datetime](conn, GET_MANY_DATETIME, _decode_hook, id_, datetime_test)


def get_many_decimal(conn: aiosqlite.Connection, *, id_: int, decimal_test: decimal.Decimal) -> QueryResults[decimal.Decimal]:
    """Fetch many from the db using the SQL query with `name: GetManyDecimal :many`.

    ```sql
    SELECT decimal_test FROM test_sqlite_types WHERE id = ? AND decimal_test = ?
    ```

    Args:
        conn:
            Connection object of type `aiosqlite.Connection` used to execute the query.
        id_: int.
        decimal_test: decimal.Decimal.

    Returns:
        Helper class of type `QueryResults[decimal.Decimal]` that allows both iteration and normal fetching of data from the db.
    """
    def _decode_hook(row: sqlite3.Row) -> decimal.Decimal:
        return row[0]
    return QueryResults[decimal.Decimal](conn, GET_MANY_DECIMAL, _decode_hook, id_, decimal_test)


def get_many_inner_sqlite_type(conn: aiosqlite.Connection, *, table_id: int) -> QueryResults[models.TestInnerSqliteType]:
    """Fetch many from the db using the SQL query with `name: GetManyInnerSqliteType :many`.

    ```sql
    SELECT table_id, int_test, bigint_test, smallint_test, tinyint_test, int2_test, int8_test, bigserial_test, blob_test, real_test, double_test, double_precision_test, float_test, numeric_test, decimal_test, boolean_test, bool_test, date_test, datetime_test, timestamp_test, character_test, varchar_test, varyingcharacter_test, nchar_test, nativecharacter_test, nvarchar_test, text_test, clob_test, json_test FROM test_inner_sqlite_types WHERE table_id = ?
    ```

    Args:
        conn:
            Connection object of type `aiosqlite.Connection` used to execute the query.
        table_id: int.

    Returns:
        Helper class of type `QueryResults[models.TestInnerSqliteType]` that allows both iteration and normal fetching of data from the db.
    """
    def _decode_hook(row: sqlite3.Row) -> models.TestInnerSqliteType:
        return models.TestInnerSqliteType(table_id=row[0], int_test=row[1], bigint_test=row[2], smallint_test=row[3], tinyint_test=row[4], int2_test=row[5], int8_test=row[6], bigserial_test=row[7], blob_test=row[8], real_test=row[9], double_test=row[10], double_precision_test=row[11], float_test=row[12], numeric_test=row[13], decimal_test=row[14], boolean_test=row[15], bool_test=row[16], date_test=row[17], datetime_test=row[18], timestamp_test=row[19], character_test=row[20], varchar_test=row[21], varyingcharacter_test=row[22], nchar_test=row[23], nativecharacter_test=row[24], nvarchar_test=row[25], text_test=row[26], clob_test=row[27], json_test=row[28])
    return QueryResults[models.TestInnerSqliteType](conn, GET_MANY_INNER_SQLITE_TYPE, _decode_hook, table_id)


def get_many_nullable_inner_sqlite_type(conn: aiosqlite.Connection, *, table_id: int, int_test: int | None) -> QueryResults[models.TestInnerSqliteType]:
    """Fetch many from the db using the SQL query with `name: GetManyNullableInnerSqliteType :many`.

    ```sql
    SELECT table_id, int_test, bigint_test, smallint_test, tinyint_test, int2_test, int8_test, bigserial_test, blob_test, real_test, double_test, double_precision_test, float_test, numeric_test, decimal_test, boolean_test, bool_test, date_test, datetime_test, timestamp_test, character_test, varchar_test, varyingcharacter_test, nchar_test, nativecharacter_test, nvarchar_test, text_test, clob_test, json_test FROM test_inner_sqlite_types WHERE table_id = ? AND int_test = ?
    ```

    Args:
        conn:
            Connection object of type `aiosqlite.Connection` used to execute the query.
        table_id: int.
        int_test: int | None.

    Returns:
        Helper class of type `QueryResults[models.TestInnerSqliteType]` that allows both iteration and normal fetching of data from the db.
    """
    def _decode_hook(row: sqlite3.Row) -> models.TestInnerSqliteType:
        return models.TestInnerSqliteType(table_id=row[0], int_test=row[1], bigint_test=row[2], smallint_test=row[3], tinyint_test=row[4], int2_test=row[5], int8_test=row[6], bigserial_test=row[7], blob_test=row[8], real_test=row[9], double_test=row[10], double_precision_test=row[11], float_test=row[12], numeric_test=row[13], decimal_test=row[14], boolean_test=row[15], bool_test=row[16], date_test=row[17], datetime_test=row[18], timestamp_test=row[19], character_test=row[20], varchar_test=row[21], varyingcharacter_test=row[22], nchar_test=row[23], nativecharacter_test=row[24], nvarchar_test=row[25], text_test=row[26], clob_test=row[27], json_test=row[28])
    return QueryResults[models.TestInnerSqliteType](conn, GET_MANY_NULLABLE_INNER_SQLITE_TYPE, _decode_hook, table_id, int_test)


def get_many_sqlite_type(conn: aiosqlite.Connection, *, id_: int) -> QueryResults[models.TestSqliteType]:
    """Fetch many from the db using the SQL query with `name: GetManySqliteType :many`.

    ```sql
    SELECT id, int_test, bigint_test, smallint_test, tinyint_test, int2_test, int8_test, bigserial_test, blob_test, real_test, double_test, double_precision_test, float_test, numeric_test, decimal_test, boolean_test, bool_test, date_test, datetime_test, timestamp_test, character_test, varchar_test, varyingcharacter_test, nchar_test, nativecharacter_test, nvarchar_test, text_test, clob_test, json_test FROM test_sqlite_types WHERE id = ?
    ```

    Args:
        conn:
            Connection object of type `aiosqlite.Connection` used to execute the query.
        id_: int.

    Returns:
        Helper class of type `QueryResults[models.TestSqliteType]` that allows both iteration and normal fetching of data from the db.
    """
    def _decode_hook(row: sqlite3.Row) -> models.TestSqliteType:
        return models.TestSqliteType(id=row[0], int_test=row[1], bigint_test=row[2], smallint_test=row[3], tinyint_test=row[4], int2_test=row[5], int8_test=row[6], bigserial_test=row[7], blob_test=row[8], real_test=row[9], double_test=row[10], double_precision_test=row[11], float_test=row[12], numeric_test=row[13], decimal_test=row[14], boolean_test=row[15], bool_test=row[16], date_test=row[17], datetime_test=row[18], timestamp_test=row[19], character_test=row[20], varchar_test=row[21], varyingcharacter_test=row[22], nchar_test=row[23], nativecharacter_test=row[24], nvarchar_test=row[25], text_test=row[26], clob_test=row[27], json_test=row[28])
    return QueryResults[models.TestSqliteType](conn, GET_MANY_SQLITE_TYPE, _decode_hook, id_)


def get_many_timestamp(conn: aiosqlite.Connection, *, id_: int, timestamp_test: datetime.datetime) -> QueryResults[datetime.datetime]:
    """Fetch many from the db using the SQL query with `name: GetManyTimestamp :many`.

    ```sql
    SELECT timestamp_test FROM test_sqlite_types WHERE id = ? AND timestamp_test = ?
    ```

    Args:
        conn:
            Connection object of type `aiosqlite.Connection` used to execute the query.
        id_: int.
        timestamp_test: datetime.datetime.

    Returns:
        Helper class of type `QueryResults[datetime.datetime]` that allows both iteration and normal fetching of data from the db.
    """
    def _decode_hook(row: sqlite3.Row) -> datetime.datetime:
        return row[0]
    return QueryResults[datetime.datetime](conn, GET_MANY_TIMESTAMP, _decode_hook, id_, timestamp_test)


async def get_one_blob(conn: aiosqlite.Connection, *, id_: int, blob_test: memoryview) -> memoryview | None:
    """Fetch one from the db using the SQL query with `name: GetOneBlob :one`.

    ```sql
    SELECT blob_test FROM test_sqlite_types WHERE id = ? AND blob_test = ?
    ```

    Args:
        conn:
            Connection object of type `aiosqlite.Connection` used to execute the query.
        id_: int.
        blob_test: memoryview.

    Returns:
        Result of type `memoryview` fetched from the db. Will be `None` if not found.
    """
    row = await (await conn.execute(GET_ONE_BLOB,(id_, blob_test))).fetchone()
    if row is None:
        return None
    return row[0]


async def get_one_bool(conn: aiosqlite.Connection, *, id_: int, bool_test: bool) -> bool | None:
    """Fetch one from the db using the SQL query with `name: GetOneBool :one`.

    ```sql
    SELECT bool_test FROM test_sqlite_types WHERE id = ? AND bool_test = ?
    ```

    Args:
        conn:
            Connection object of type `aiosqlite.Connection` used to execute the query.
        id_: int.
        bool_test: bool.

    Returns:
        Result of type `bool` fetched from the db. Will be `None` if not found.
    """
    row = await (await conn.execute(GET_ONE_BOOL,(id_, bool_test))).fetchone()
    if row is None:
        return None
    return row[0]


async def get_one_boolean(conn: aiosqlite.Connection, *, id_: int, boolean_test: bool) -> bool | None:
    """Fetch one from the db using the SQL query with `name: GetOneBoolean :one`.

    ```sql
    SELECT boolean_test FROM test_sqlite_types WHERE id = ? AND boolean_test = ?
    ```

    Args:
        conn:
            Connection object of type `aiosqlite.Connection` used to execute the query.
        id_: int.
        boolean_test: bool.

    Returns:
        Result of type `bool` fetched from the db. Will be `None` if not found.
    """
    row = await (await conn.execute(GET_ONE_BOOLEAN,(id_, boolean_test))).fetchone()
    if row is None:
        return None
    return row[0]


async def get_one_date(conn: aiosqlite.Connection, *, id_: int, date_test: datetime.date) -> datetime.date | None:
    """Fetch one from the db using the SQL query with `name: GetOneDate :one`.

    ```sql
    SELECT date_test FROM test_sqlite_types WHERE id = ? AND date_test = ?
    ```

    Args:
        conn:
            Connection object of type `aiosqlite.Connection` used to execute the query.
        id_: int.
        date_test: datetime.date.

    Returns:
        Result of type `datetime.date` fetched from the db. Will be `None` if not found.
    """
    row = await (await conn.execute(GET_ONE_DATE,(id_, date_test))).fetchone()
    if row is None:
        return None
    return row[0]


async def get_one_datetime(conn: aiosqlite.Connection, *, id_: int, datetime_test: datetime.datetime) -> datetime.datetime | None:
    """Fetch one from the db using the SQL query with `name: GetOneDatetime :one`.

    ```sql
    SELECT datetime_test FROM test_sqlite_types WHERE id = ? AND datetime_test = ?
    ```

    Args:
        conn:
            Connection object of type `aiosqlite.Connection` used to execute the query.
        id_: int.
        datetime_test: datetime.datetime.

    Returns:
        Result of type `datetime.datetime` fetched from the db. Will be `None` if not found.
    """
    row = await (await conn.execute(GET_ONE_DATETIME,(id_, datetime_test))).fetchone()
    if row is None:
        return None
    return row[0]


async def get_one_decimal(conn: aiosqlite.Connection, *, id_: int, decimal_test: decimal.Decimal) -> decimal.Decimal | None:
    """Fetch one from the db using the SQL query with `name: GetOneDecimal :one`.

    ```sql
    SELECT decimal_test FROM test_sqlite_types WHERE id = ? AND decimal_test = ?
    ```

    Args:
        conn:
            Connection object of type `aiosqlite.Connection` used to execute the query.
        id_: int.
        decimal_test: decimal.Decimal.

    Returns:
        Result of type `decimal.Decimal` fetched from the db. Will be `None` if not found.
    """
    row = await (await conn.execute(GET_ONE_DECIMAL,(id_, decimal_test))).fetchone()
    if row is None:
        return None
    return row[0]


async def get_one_inner_sqlite_type(conn: aiosqlite.Connection, *, table_id: int) -> models.TestInnerSqliteType | None:
    """Fetch one from the db using the SQL query with `name: GetOneInnerSqliteType :one`.

    ```sql
    SELECT table_id, int_test, bigint_test, smallint_test, tinyint_test, int2_test, int8_test, bigserial_test, blob_test, real_test, double_test, double_precision_test, float_test, numeric_test, decimal_test, boolean_test, bool_test, date_test, datetime_test, timestamp_test, character_test, varchar_test, varyingcharacter_test, nchar_test, nativecharacter_test, nvarchar_test, text_test, clob_test, json_test FROM test_inner_sqlite_types WHERE table_id = ?
    ```

    Args:
        conn:
            Connection object of type `aiosqlite.Connection` used to execute the query.
        table_id: int.

    Returns:
        Result of type `models.TestInnerSqliteType` fetched from the db. Will be `None` if not found.
    """
    row = await (await conn.execute(GET_ONE_INNER_SQLITE_TYPE,(table_id, ))).fetchone()
    if row is None:
        return None
    return models.TestInnerSqliteType(table_id=row[0], int_test=row[1], bigint_test=row[2], smallint_test=row[3], tinyint_test=row[4], int2_test=row[5], int8_test=row[6], bigserial_test=row[7], blob_test=row[8], real_test=row[9], double_test=row[10], double_precision_test=row[11], float_test=row[12], numeric_test=row[13], decimal_test=row[14], boolean_test=row[15], bool_test=row[16], date_test=row[17], datetime_test=row[18], timestamp_test=row[19], character_test=row[20], varchar_test=row[21], varyingcharacter_test=row[22], nchar_test=row[23], nativecharacter_test=row[24], nvarchar_test=row[25], text_test=row[26], clob_test=row[27], json_test=row[28])


async def get_one_sqlite_type(conn: aiosqlite.Connection, *, id_: int) -> models.TestSqliteType | None:
    """Fetch one from the db using the SQL query with `name: GetOneSqliteType :one`.

    ```sql
    SELECT id, int_test, bigint_test, smallint_test, tinyint_test, int2_test, int8_test, bigserial_test, blob_test, real_test, double_test, double_precision_test, float_test, numeric_test, decimal_test, boolean_test, bool_test, date_test, datetime_test, timestamp_test, character_test, varchar_test, varyingcharacter_test, nchar_test, nativecharacter_test, nvarchar_test, text_test, clob_test, json_test FROM test_sqlite_types WHERE id = ?
    ```

    Args:
        conn:
            Connection object of type `aiosqlite.Connection` used to execute the query.
        id_: int.

    Returns:
        Result of type `models.TestSqliteType` fetched from the db. Will be `None` if not found.
    """
    row = await (await conn.execute(GET_ONE_SQLITE_TYPE,(id_, ))).fetchone()
    if row is None:
        return None
    return models.TestSqliteType(id=row[0], int_test=row[1], bigint_test=row[2], smallint_test=row[3], tinyint_test=row[4], int2_test=row[5], int8_test=row[6], bigserial_test=row[7], blob_test=row[8], real_test=row[9], double_test=row[10], double_precision_test=row[11], float_test=row[12], numeric_test=row[13], decimal_test=row[14], boolean_test=row[15], bool_test=row[16], date_test=row[17], datetime_test=row[18], timestamp_test=row[19], character_test=row[20], varchar_test=row[21], varyingcharacter_test=row[22], nchar_test=row[23], nativecharacter_test=row[24], nvarchar_test=row[25], text_test=row[26], clob_test=row[27], json_test=row[28])


async def get_one_timestamp(conn: aiosqlite.Connection, *, id_: int, timestamp_test: datetime.datetime) -> datetime.datetime | None:
    """Fetch one from the db using the SQL query with `name: GetOneTimestamp :one`.

    ```sql
    SELECT timestamp_test FROM test_sqlite_types WHERE id = ? AND timestamp_test = ?
    ```

    Args:
        conn:
            Connection object of type `aiosqlite.Connection` used to execute the query.
        id_: int.
        timestamp_test: datetime.datetime.

    Returns:
        Result of type `datetime.datetime` fetched from the db. Will be `None` if not found.
    """
    row = await (await conn.execute(GET_ONE_TIMESTAMP,(id_, timestamp_test))).fetchone()
    if row is None:
        return None
    return row[0]


async def insert_last_id_one_sqlite_type(conn: aiosqlite.Connection, *, id_: int, int_test: int, bigint_test: int, smallint_test: int, tinyint_test: int, int2_test: int, int8_test: int, bigserial_test: int, blob_test: memoryview, real_test: float, double_test: float, double_precision_test: float, float_test: float, numeric_test: float, decimal_test: decimal.Decimal, boolean_test: bool, bool_test: bool, date_test: datetime.date, datetime_test: datetime.datetime, timestamp_test: datetime.datetime, character_test: str, varchar_test: str, varyingcharacter_test: str, nchar_test: str, nativecharacter_test: str, nvarchar_test: str, text_test: str, clob_test: str, json_test: str) -> int | None:
    """Execute SQL query with `name: InsertLastIdOneSqliteType :execlastid` and return the id of the last affected row.

    ```sql
    INSERT INTO test_sqlite_types (
        id, int_test, bigint_test, smallint_test, tinyint_test, int2_test, int8_test, bigserial_test,
        blob_test, real_test, double_test, double_precision_test, float_test, numeric_test, decimal_test,
        boolean_test, bool_test, date_test, datetime_test, timestamp_test,
        character_test, varchar_test, varyingcharacter_test, nchar_test, nativecharacter_test,
        nvarchar_test, text_test, clob_test, json_test
    ) VALUES (
                 ?, ?, ?, ?, ?, ?, ?, ?,
                 ?, ?, ?, ?, ?, ?, ?,
                 ?, ?, ?, ?, ?,
                 ?, ?, ?, ?, ?, ?, ?, ?, ?
             )
    ```

    Args:
        conn:
            Connection object of type `aiosqlite.Connection` used to execute the query.
        id_: int.
        int_test: int.
        bigint_test: int.
        smallint_test: int.
        tinyint_test: int.
        int2_test: int.
        int8_test: int.
        bigserial_test: int.
        blob_test: memoryview.
        real_test: float.
        double_test: float.
        double_precision_test: float.
        float_test: float.
        numeric_test: float.
        decimal_test: decimal.Decimal.
        boolean_test: bool.
        bool_test: bool.
        date_test: datetime.date.
        datetime_test: datetime.datetime.
        timestamp_test: datetime.datetime.
        character_test: str.
        varchar_test: str.
        varyingcharacter_test: str.
        nchar_test: str.
        nativecharacter_test: str.
        nvarchar_test: str.
        text_test: str.
        clob_test: str.
        json_test: str.

    Returns:
        The id (`int | None`) of the last affected row. Will be `None` if no rows are affected.
    """
    return (await conn.execute(INSERT_LAST_ID_ONE_SQLITE_TYPE,(id_, int_test, bigint_test, smallint_test, tinyint_test, int2_test, int8_test, bigserial_test, blob_test, real_test, double_test, double_precision_test, float_test, numeric_test, decimal_test, boolean_test, bool_test, date_test, datetime_test, timestamp_test, character_test, varchar_test, varyingcharacter_test, nchar_test, nativecharacter_test, nvarchar_test, text_test, clob_test, json_test))).lastrowid


async def insert_one_inner_sqlite_type(conn: aiosqlite.Connection, *, table_id: int, int_test: int | None, bigint_test: int | None, smallint_test: int | None, tinyint_test: int | None, int2_test: int | None, int8_test: int | None, bigserial_test: int | None, blob_test: memoryview | None, real_test: float | None, double_test: float | None, double_precision_test: float | None, float_test: float | None, numeric_test: float | None, decimal_test: decimal.Decimal | None, boolean_test: bool | None, bool_test: bool | None, date_test: datetime.date | None, datetime_test: datetime.datetime | None, timestamp_test: datetime.datetime | None, character_test: str | None, varchar_test: str | None, varyingcharacter_test: str | None, nchar_test: str | None, nativecharacter_test: str | None, nvarchar_test: str | None, text_test: str | None, clob_test: str | None, json_test: str | None) -> None:
    """Execute SQL query with `name: InsertOneInnerSqliteType :exec`.

    ```sql
    INSERT INTO test_inner_sqlite_types (
        table_id, int_test, bigint_test, smallint_test, tinyint_test, int2_test, int8_test, bigserial_test,
        blob_test, real_test, double_test, double_precision_test, float_test, numeric_test, decimal_test,
        boolean_test, bool_test, date_test, datetime_test, timestamp_test,
        character_test, varchar_test, varyingcharacter_test, nchar_test, nativecharacter_test,
        nvarchar_test, text_test, clob_test, json_test
    ) VALUES (
                 ?, ?, ?, ?, ?, ?, ?, ?,
                 ?, ?, ?, ?, ?, ?, ?,
                 ?, ?, ?, ?, ?,
                 ?, ?, ?, ?, ?, ?, ?, ?, ?
             )
    ```

    Args:
        conn:
            Connection object of type `aiosqlite.Connection` used to execute the query.
        table_id: int.
        int_test: int | None.
        bigint_test: int | None.
        smallint_test: int | None.
        tinyint_test: int | None.
        int2_test: int | None.
        int8_test: int | None.
        bigserial_test: int | None.
        blob_test: memoryview | None.
        real_test: float | None.
        double_test: float | None.
        double_precision_test: float | None.
        float_test: float | None.
        numeric_test: float | None.
        decimal_test: decimal.Decimal | None.
        boolean_test: bool | None.
        bool_test: bool | None.
        date_test: datetime.date | None.
        datetime_test: datetime.datetime | None.
        timestamp_test: datetime.datetime | None.
        character_test: str | None.
        varchar_test: str | None.
        varyingcharacter_test: str | None.
        nchar_test: str | None.
        nativecharacter_test: str | None.
        nvarchar_test: str | None.
        text_test: str | None.
        clob_test: str | None.
        json_test: str | None.
    """
    await conn.execute(INSERT_ONE_INNER_SQLITE_TYPE,(table_id, int_test, bigint_test, smallint_test, tinyint_test, int2_test, int8_test, bigserial_test, blob_test, real_test, double_test, double_precision_test, float_test, numeric_test, decimal_test, boolean_test, bool_test, date_test, datetime_test, timestamp_test, character_test, varchar_test, varyingcharacter_test, nchar_test, nativecharacter_test, nvarchar_test, text_test, clob_test, json_test))


async def insert_one_sqlite_type(conn: aiosqlite.Connection, *, id_: int, int_test: int, bigint_test: int, smallint_test: int, tinyint_test: int, int2_test: int, int8_test: int, bigserial_test: int, blob_test: memoryview, real_test: float, double_test: float, double_precision_test: float, float_test: float, numeric_test: float, decimal_test: decimal.Decimal, boolean_test: bool, bool_test: bool, date_test: datetime.date, datetime_test: datetime.datetime, timestamp_test: datetime.datetime, character_test: str, varchar_test: str, varyingcharacter_test: str, nchar_test: str, nativecharacter_test: str, nvarchar_test: str, text_test: str, clob_test: str, json_test: str) -> None:
    """Execute SQL query with `name: InsertOneSqliteType :exec`.

    ```sql
    INSERT INTO test_sqlite_types (
        id, int_test, bigint_test, smallint_test, tinyint_test, int2_test, int8_test, bigserial_test,
        blob_test, real_test, double_test, double_precision_test, float_test, numeric_test, decimal_test,
        boolean_test, bool_test, date_test, datetime_test, timestamp_test,
        character_test, varchar_test, varyingcharacter_test, nchar_test, nativecharacter_test,
        nvarchar_test, text_test, clob_test, json_test
    ) VALUES (
                 ?, ?, ?, ?, ?, ?, ?, ?,
                 ?, ?, ?, ?, ?, ?, ?,
                 ?, ?, ?, ?, ?,
                 ?, ?, ?, ?, ?, ?, ?, ?, ?
             )
    ```

    Args:
        conn:
            Connection object of type `aiosqlite.Connection` used to execute the query.
        id_: int.
        int_test: int.
        bigint_test: int.
        smallint_test: int.
        tinyint_test: int.
        int2_test: int.
        int8_test: int.
        bigserial_test: int.
        blob_test: memoryview.
        real_test: float.
        double_test: float.
        double_precision_test: float.
        float_test: float.
        numeric_test: float.
        decimal_test: decimal.Decimal.
        boolean_test: bool.
        bool_test: bool.
        date_test: datetime.date.
        datetime_test: datetime.datetime.
        timestamp_test: datetime.datetime.
        character_test: str.
        varchar_test: str.
        varyingcharacter_test: str.
        nchar_test: str.
        nativecharacter_test: str.
        nvarchar_test: str.
        text_test: str.
        clob_test: str.
        json_test: str.
    """
    await conn.execute(INSERT_ONE_SQLITE_TYPE,(id_, int_test, bigint_test, smallint_test, tinyint_test, int2_test, int8_test, bigserial_test, blob_test, real_test, double_test, double_precision_test, float_test, numeric_test, decimal_test, boolean_test, bool_test, date_test, datetime_test, timestamp_test, character_test, varchar_test, varyingcharacter_test, nchar_test, nativecharacter_test, nvarchar_test, text_test, clob_test, json_test))


async def insert_result_one_sqlite_type(conn: aiosqlite.Connection, *, id_: int, int_test: int, bigint_test: int, smallint_test: int, tinyint_test: int, int2_test: int, int8_test: int, bigserial_test: int, blob_test: memoryview, real_test: float, double_test: float, double_precision_test: float, float_test: float, numeric_test: float, decimal_test: decimal.Decimal, boolean_test: bool, bool_test: bool, date_test: datetime.date, datetime_test: datetime.datetime, timestamp_test: datetime.datetime, character_test: str, varchar_test: str, varyingcharacter_test: str, nchar_test: str, nativecharacter_test: str, nvarchar_test: str, text_test: str, clob_test: str, json_test: str) -> aiosqlite.Cursor:
    """Execute and return the result of SQL query with `name: InsertResultOneSqliteType :execresult`.

    ```sql
    INSERT INTO test_sqlite_types (
        id, int_test, bigint_test, smallint_test, tinyint_test, int2_test, int8_test, bigserial_test,
        blob_test, real_test, double_test, double_precision_test, float_test, numeric_test, decimal_test,
        boolean_test, bool_test, date_test, datetime_test, timestamp_test,
        character_test, varchar_test, varyingcharacter_test, nchar_test, nativecharacter_test,
        nvarchar_test, text_test, clob_test, json_test
    ) VALUES (
                 ?, ?, ?, ?, ?, ?, ?, ?,
                 ?, ?, ?, ?, ?, ?, ?,
                 ?, ?, ?, ?, ?,
                 ?, ?, ?, ?, ?, ?, ?, ?, ?
             )
    ```

    Args:
        conn:
            Connection object of type `aiosqlite.Connection` used to execute the query.
        id_: int.
        int_test: int.
        bigint_test: int.
        smallint_test: int.
        tinyint_test: int.
        int2_test: int.
        int8_test: int.
        bigserial_test: int.
        blob_test: memoryview.
        real_test: float.
        double_test: float.
        double_precision_test: float.
        float_test: float.
        numeric_test: float.
        decimal_test: decimal.Decimal.
        boolean_test: bool.
        bool_test: bool.
        date_test: datetime.date.
        datetime_test: datetime.datetime.
        timestamp_test: datetime.datetime.
        character_test: str.
        varchar_test: str.
        varyingcharacter_test: str.
        nchar_test: str.
        nativecharacter_test: str.
        nvarchar_test: str.
        text_test: str.
        clob_test: str.
        json_test: str.

    Returns:
        The result of type `aiosqlite.Cursor` returned when executing the query.
    """
    return await conn.execute(INSERT_RESULT_ONE_SQLITE_TYPE,(id_, int_test, bigint_test, smallint_test, tinyint_test, int2_test, int8_test, bigserial_test, blob_test, real_test, double_test, double_precision_test, float_test, numeric_test, decimal_test, boolean_test, bool_test, date_test, datetime_test, timestamp_test, character_test, varchar_test, varyingcharacter_test, nchar_test, nativecharacter_test, nvarchar_test, text_test, clob_test, json_test))


async def insert_rows_one_sqlite_type(conn: aiosqlite.Connection, *, id_: int, int_test: int, bigint_test: int, smallint_test: int, tinyint_test: int, int2_test: int, int8_test: int, bigserial_test: int, blob_test: memoryview, real_test: float, double_test: float, double_precision_test: float, float_test: float, numeric_test: float, decimal_test: decimal.Decimal, boolean_test: bool, bool_test: bool, date_test: datetime.date, datetime_test: datetime.datetime, timestamp_test: datetime.datetime, character_test: str, varchar_test: str, varyingcharacter_test: str, nchar_test: str, nativecharacter_test: str, nvarchar_test: str, text_test: str, clob_test: str, json_test: str) -> int:
    """Execute SQL query with `name: InsertRowsOneSqliteType :execrows` and return the number of affected rows.

    ```sql
    INSERT INTO test_sqlite_types (
        id, int_test, bigint_test, smallint_test, tinyint_test, int2_test, int8_test, bigserial_test,
        blob_test, real_test, double_test, double_precision_test, float_test, numeric_test, decimal_test,
        boolean_test, bool_test, date_test, datetime_test, timestamp_test,
        character_test, varchar_test, varyingcharacter_test, nchar_test, nativecharacter_test,
        nvarchar_test, text_test, clob_test, json_test
    ) VALUES (
                 ?, ?, ?, ?, ?, ?, ?, ?,
                 ?, ?, ?, ?, ?, ?, ?,
                 ?, ?, ?, ?, ?,
                 ?, ?, ?, ?, ?, ?, ?, ?, ?
             )
    ```

    Args:
        conn:
            Connection object of type `aiosqlite.Connection` used to execute the query.
        id_: int.
        int_test: int.
        bigint_test: int.
        smallint_test: int.
        tinyint_test: int.
        int2_test: int.
        int8_test: int.
        bigserial_test: int.
        blob_test: memoryview.
        real_test: float.
        double_test: float.
        double_precision_test: float.
        float_test: float.
        numeric_test: float.
        decimal_test: decimal.Decimal.
        boolean_test: bool.
        bool_test: bool.
        date_test: datetime.date.
        datetime_test: datetime.datetime.
        timestamp_test: datetime.datetime.
        character_test: str.
        varchar_test: str.
        varyingcharacter_test: str.
        nchar_test: str.
        nativecharacter_test: str.
        nvarchar_test: str.
        text_test: str.
        clob_test: str.
        json_test: str.

    Returns:
        The number (`int`) of affected rows. This will be -1 for queries like `CREATE TABLE`.
    """
    return (await conn.execute(INSERT_ROWS_ONE_SQLITE_TYPE,(id_, int_test, bigint_test, smallint_test, tinyint_test, int2_test, int8_test, bigserial_test, blob_test, real_test, double_test, double_precision_test, float_test, numeric_test, decimal_test, boolean_test, bool_test, date_test, datetime_test, timestamp_test, character_test, varchar_test, varyingcharacter_test, nchar_test, nativecharacter_test, nvarchar_test, text_test, clob_test, json_test))).rowcount


async def update_last_id_one_sqlite_type(conn: aiosqlite.Connection, *, id_: int) -> int | None:
    """Execute SQL query with `name: UpdateLastIdOneSqliteType :execlastid` and return the id of the last affected row.

    ```sql
    UPDATE test_sqlite_types
    SET int_test = 187
    WHERE test_sqlite_types.id = ?
    ```

    Args:
        conn:
            Connection object of type `aiosqlite.Connection` used to execute the query.
        id_: int.

    Returns:
        The id (`int | None`) of the last affected row. Will be `None` if no rows are affected.
    """
    return (await conn.execute(UPDATE_LAST_ID_ONE_SQLITE_TYPE,(id_, ))).lastrowid


async def update_result_one_sqlite_type(conn: aiosqlite.Connection, *, id_: int) -> aiosqlite.Cursor:
    """Execute and return the result of SQL query with `name: UpdateResultOneSqliteType :execresult`.

    ```sql
    UPDATE test_sqlite_types
    SET int_test = 187
    WHERE test_sqlite_types.id = ?
    ```

    Args:
        conn:
            Connection object of type `aiosqlite.Connection` used to execute the query.
        id_: int.

    Returns:
        The result of type `aiosqlite.Cursor` returned when executing the query.
    """
    return await conn.execute(UPDATE_RESULT_ONE_SQLITE_TYPE,(id_, ))


async def update_rows_one_sqlite_type(conn: aiosqlite.Connection, *, id_: int) -> int:
    """Execute SQL query with `name: UpdateRowsOneSqliteType :execrows` and return the number of affected rows.

    ```sql
    UPDATE test_sqlite_types
    SET int_test = 187
    WHERE test_sqlite_types.id = ?
    ```

    Args:
        conn:
            Connection object of type `aiosqlite.Connection` used to execute the query.
        id_: int.

    Returns:
        The number (`int`) of affected rows. This will be -1 for queries like `CREATE TABLE`.
    """
    return (await conn.execute(UPDATE_ROWS_ONE_SQLITE_TYPE,(id_, ))).rowcount
