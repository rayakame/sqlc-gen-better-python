# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.28.0
#   sqlc-gen-better-python 0.0.1
from __future__ import annotations

__all__: typing.Sequence[str] = (
    "create_author",
    "delete_author",
    "get_author",
    "list_authors",
    "update_author",
    "update_author_t",
    "upsert_author_name",
)

import dataclasses
import typing

import aiosqlite

from test import models

CREATE_AUTHOR = """-- name: CreateAuthor :one
INSERT INTO authors (
    name, bio
) VALUES (
             ?, ?
         )
    RETURNING id, name, bio
"""


@dataclasses.dataclass()
class CreateAuthorParams:
    name: str
    bio: typing.Optional[str]


async def create_author(conn: aiosqlite.Connection, arg: CreateAuthorParams) -> typing.Optional[models.Author]:
    row = await (await conn.execute(CREATE_AUTHOR, arg.name, arg.bio)).fetchone()
    if row is None:
        return None
    return models.Author(id=row[0], name=row[1], bio=row[2])


DELETE_AUTHOR = """-- name: DeleteAuthor :exec
DELETE FROM authors
WHERE id = ?
"""


async def delete_author(conn: aiosqlite.Connection, id: int) -> None:
    await conn.execute(DELETE_AUTHOR, id)


GET_AUTHOR = """-- name: GetAuthor :one
SELECT id, name FROM authors
WHERE id = ? LIMIT 1
"""


@dataclasses.dataclass()
class GetAuthorRow:
    id: int
    name: str


async def get_author(conn: aiosqlite.Connection, id: int) -> typing.Optional[GetAuthorRow]:
    row = await (await conn.execute(GET_AUTHOR, id)).fetchone()
    if row is None:
        return None
    return GetAuthorRow(id=row[0], name=row[1])


LIST_AUTHORS = """-- name: ListAuthors :many
SELECT id, name, bio FROM authors
WHERE id IN (/*SLICE:ids*/?)
ORDER BY name
"""


async def list_authors(conn: aiosqlite.Connection, ids: typing.Sequence[int]) -> typing.AsyncIterator[models.Author]:
    stream = await conn.execute(LIST_AUTHORS, ids)
    async for row in stream:
        yield models.Author(id=row[0], name=row[1], bio=row[2])


UPDATE_AUTHOR = """-- name: UpdateAuthor :exec
UPDATE authors
set name = ?,
    bio = ?
WHERE id = ?
"""


@dataclasses.dataclass()
class UpdateAuthorParams:
    name: str
    bio: typing.Optional[str]
    id: int


async def update_author(conn: aiosqlite.Connection, arg: UpdateAuthorParams) -> None:
    await conn.execute(UPDATE_AUTHOR, arg.name, arg.bio, arg.id)


UPDATE_AUTHOR_T = """-- name: UpdateAuthorT :one
UPDATE authors
SET
    name = coalesce(?1, name),
    bio = coalesce(?2, bio)
WHERE id = ?3
    RETURNING id, name, bio
"""


@dataclasses.dataclass()
class UpdateAuthorTParams:
    name: typing.Optional[str]
    bio: typing.Optional[str]
    id: int


async def update_author_t(conn: aiosqlite.Connection, arg: UpdateAuthorTParams) -> typing.Optional[models.Author]:
    row = await (await conn.execute(UPDATE_AUTHOR_T, arg.name, arg.bio, arg.id)).fetchone()
    if row is None:
        return None
    return models.Author(id=row[0], name=row[1], bio=row[2])


UPSERT_AUTHOR_NAME = """-- name: UpsertAuthorName :one
UPDATE authors
SET name = CASE WHEN ?2 THEN ? ELSE name END
    RETURNING id, name, bio
"""


@dataclasses.dataclass()
class UpsertAuthorNameParams:
    set_name: str
    name: str


async def upsert_author_name(conn: aiosqlite.Connection, arg: UpsertAuthorNameParams) -> typing.Optional[models.Author]:
    row = await (await conn.execute(UPSERT_AUTHOR_NAME, arg.set_name, arg.name)).fetchone()
    if row is None:
        return None
    return models.Author(id=row[0], name=row[1], bio=row[2])
