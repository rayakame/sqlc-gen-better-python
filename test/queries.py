# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.28.0
#   sqlc-gen-better-python 0.0.1
from __future__ import annotations

__all__: typing.Sequence[str] = (
    "CreateAuthorParams",
    "GetAuthorRow",
    "Queries",
    "UpdateAuthorParams",
    "UpdateAuthorTParams",
    "UpsertAuthorNameParams",
)

import dataclasses
import typing

import aiosqlite

from test import models


@dataclasses.dataclass()
class CreateAuthorParams:
    name: str
    bio: typing.Optional[str]


@dataclasses.dataclass()
class GetAuthorRow:
    id: int
    name: str


@dataclasses.dataclass()
class UpdateAuthorParams:
    name: str
    bio: typing.Optional[str]
    id: int


@dataclasses.dataclass()
class UpdateAuthorTParams:
    name: typing.Optional[str]
    bio: typing.Optional[str]
    id: int


@dataclasses.dataclass()
class UpsertAuthorNameParams:
    set_name: str
    name: str


CREATE_AUTHOR: typing.Final[str] = """-- name: CreateAuthor :one
INSERT INTO authors (
    name, bio
) VALUES (
             ?, ?
         )
    RETURNING id, name, bio
"""

DELETE_AUTHOR: typing.Final[str] = """-- name: DeleteAuthor :exec
DELETE FROM authors
WHERE id = ?
"""

GET_AUTHOR: typing.Final[str] = """-- name: GetAuthor :one
SELECT id, name FROM authors
WHERE id = ? LIMIT 1
"""

LIST_AUTHORS: typing.Final[str] = """-- name: ListAuthors :many
SELECT id, name, bio FROM authors
WHERE id IN (/*SLICE:ids*/?)
ORDER BY name
"""

UPDATE_AUTHOR: typing.Final[str] = """-- name: UpdateAuthor :exec
UPDATE authors
set name = ?,
    bio = ?
WHERE id = ?
"""

UPDATE_AUTHOR_T: typing.Final[str] = """-- name: UpdateAuthorT :one
UPDATE authors
SET
    name = coalesce(?1, name),
    bio = coalesce(?2, bio)
WHERE id = ?3
    RETURNING id, name, bio
"""

UPSERT_AUTHOR_NAME: typing.Final[str] = """-- name: UpsertAuthorName :one
UPDATE authors
SET name = CASE WHEN ?2 THEN ? ELSE name END
    RETURNING id, name, bio
"""


class Queries:
    __slots__ = ("_conn",)

    def __init__(self, conn: aiosqlite.Connection):
        self._conn = conn

    async def create_author(self, arg: CreateAuthorParams) -> typing.Optional[models.Author]:
        row = await (await self._conn.execute(CREATE_AUTHOR, arg.name, arg.bio)).fetchone()
        if row is None:
            return None
        return models.Author(id=row[0], name=row[1], bio=row[2])

    async def delete_author(self, id: int) -> None:
        await self._conn.execute(DELETE_AUTHOR, id)

    async def get_author(self, id: int) -> typing.Optional[GetAuthorRow]:
        row = await (await self._conn.execute(GET_AUTHOR, id)).fetchone()
        if row is None:
            return None
        return GetAuthorRow(id=row[0], name=row[1])

    async def list_authors(self, ids: typing.Sequence[int]) -> typing.AsyncIterator[models.Author]:
        stream = await self._conn.execute(LIST_AUTHORS, ids)
        async for row in stream:
            yield models.Author(id=row[0], name=row[1], bio=row[2])

    async def update_author(self, arg: UpdateAuthorParams) -> None:
        await self._conn.execute(UPDATE_AUTHOR, arg.name, arg.bio, arg.id)

    async def update_author_t(self, arg: UpdateAuthorTParams) -> typing.Optional[models.Author]:
        row = await (await self._conn.execute(UPDATE_AUTHOR_T, arg.name, arg.bio, arg.id)).fetchone()
        if row is None:
            return None
        return models.Author(id=row[0], name=row[1], bio=row[2])

    async def upsert_author_name(self, arg: UpsertAuthorNameParams) -> typing.Optional[models.Author]:
        row = await (await self._conn.execute(UPSERT_AUTHOR_NAME, arg.set_name, arg.name)).fetchone()
        if row is None:
            return None
        return models.Author(id=row[0], name=row[1], bio=row[2])
